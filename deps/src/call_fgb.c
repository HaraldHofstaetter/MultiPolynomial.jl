#include <stdio.h>
#define LIBMODE 2
#define USE_MY_OWN_IO 0
#if USE_MY_OWN_IO
#define CALL_FGB_DO_NOT_DEFINE
#endif 

#include "call_fgb.h"
#include "gmp.h"
#define FGb_MAXI_BASE 100000


int main(int argc,char**argv)
{
    //Dpol input_basis[FGb_MAXI_BASE];
    Dpol *input_basis;
    Dpol output_basis[FGb_MAXI_BASE];

    int nb_vars;
    int n_input;
    int n_output;
    int nb;
    int nb_mons;
    int p, m, v;
    UI32 *e;
    //I32 e[1024];
    UI32* ei;
    mpz_t u;
    Dpol_INT prev;
  
    //char** vars = NULL;
    char* vars[6]={"x1","x2","x3","x4","x5","x6"}; /* name of the variables (can be anything) */
    char buf[1024];


    double t0;

    SFGB_Options options;
    
    UI32* Mons;
    mpz_ptr* cfs;    
    int code;


    FGB(saveptr)(); /* First thing to do : GMP origmal memory allocators are saved */
    init_FGb_Integers(); /* init FGb for integers computation  */
    threads_FGb(1);

    scanf("%d", &nb_vars);
    FGB(PowerSet)(nb_vars,0,vars); /* Define the monomial ordering: DRL(k1,k2) where 
		   		      k1 is the size of the 1st block of variables 
				      k2 is the size of the 2nd block of variables 
				      and vars is the name of the variable
				   */
    threads_FGb(1);

    scanf("%d", &n_input);

    e = (int*)malloc(sizeof(I32)*nb_vars);
    input_basis = (Dpol*)malloc(sizeof(Dpol)*n_input);

    for (p=0; p<n_input; p++) {
        scanf("%d", &nb_mons);
        prev=FGB(creat_poly)(nb_mons);
        input_basis[p]=prev;
        for (m=0; m<nb_mons; m++) {
            for (v=0; v<nb_vars; v++) {
                scanf("%d", &e[v]);
            }    
            FGB(set_expos2)(prev,m,e,nb_vars);
            mpz_inp_str(u, stdin, 10);
            FGB(set_coeff_gmp)(prev,m,u);
        }
        FGB(full_sort_poly2)(prev);/* it is recommended to sort each polynomial */
    }
    free(e);

#if 0
    printf("-- INPUT ----------\n");
    printf("%d %d\n", nb_vars, n_input);
    for (p=0; p<n_input; p++) {
        nb_mons=FGB(nb_terms)(input_basis[p]);
        printf("%d\n", nb_mons);
	Mons=(UI32*)(malloc(sizeof(UI32)*nb_vars*nb_mons));
	cfs=(mpz_ptr*)(malloc(nb_mons*sizeof(mpz_ptr)));
	code=FGB(export_poly_INT_gmp2)(nb_vars,nb_mons,cfs,Mons,input_basis[p]);
	//cfs=FGB(export_poly_INT_gmp)(nb_vars,nb_mons,Mons,input_basis[p]);
        for (m=0; m<nb_mons; m++) {
            e=Mons+m*nb_vars;
            for (v=0; v<nb_vars; v++) {
                printf("%u ", e[v]);
            }    
            mpz_out_str(stdout,10,cfs[m]);
            printf("\n");
        }    
	free(Mons);
	free(cfs);
    }
    printf("-- OUTPUT ----------\n");
#endif    

#if 1
    FGb_set_default_options(&options);
    /* overide some default parameters */
    options._env._force_elim=0; /* if force_elim=1 then return only the result of the elimination 
				    (need to define a monomial ordering DRL(k1,k2) with k2>0 ) */
    options._env._index=1000000; /* This is is the maximal size of the matrices generated by F4 
				     you can increase this value according to your memory */

    n_output=FGB(fgb)(input_basis,n_input,output_basis,FGb_MAXI_BASE,&t0,&options);
 

    printf("%d %d\n", nb_vars, n_output);
    for (p=0; p<n_output; p++) {
        nb_mons=FGB(nb_terms)(output_basis[p]);
        printf("%d\n", nb_mons);
	Mons=(UI32*)(malloc(sizeof(UI32)*nb_vars*nb_mons));
	cfs=(mpz_ptr*)(malloc(nb_mons*sizeof(mpz_ptr)));
	code=FGB(export_poly_INT_gmp2)(nb_vars,nb_mons,cfs,Mons,output_basis[p]);
        for (m=0; m<nb_mons; m++) {
            e=Mons+m*nb_vars;
            for (v=0; v<nb_vars; v++) {
                printf("%u ", e[v]);
            }    
            mpz_out_str(stdout,10,cfs[m]);
            printf("\n");
        }    
	free(Mons);
	free(cfs);
    }    
#endif

    free(input_basis);

    FGB(reset_memory)(); /* to reset Memory */
    FGB(restoreptr)(); /* restore original GMP allocators */
}
